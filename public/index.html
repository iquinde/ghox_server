<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîí Ghox P2P Voice - SRTP Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        .security-status {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            text-align: center;
        }
        .status-item {
            display: inline-block;
            margin: 10px 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 25px;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        button {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        button:hover {
            transform: translateY(-2px);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        input {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 16px;
            margin-bottom: 20px;
        }
        .logs {
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
        }
        .log-security { color: #4ECDC4; }
        .log-error { color: #FF6B6B; }
        .log-warning { color: #FFE66D; }
        .log-info { color: #95E1D3; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîí Ghox P2P Voice Test</h1>
        
        <div class="security-status">
            <h3>üîí Estado de Cifrado de Extremo a Extremo</h3>
            <div class="status-item">
                <strong>Se√±alizaci√≥n:</strong> <span id="signalingStatus">üîå Desconectado</span>
            </div>
            <div class="status-item">
                <strong>WebRTC:</strong> <span id="webrtcStatus">‚è≥ Sin conexi√≥n</span>
            </div>
            <div class="status-item">
                <strong>Audio SRTP:</strong> <span id="srtpStatus">‚è≥ Pendiente</span>
            </div>
            <div class="status-item">
                <strong>Protocolo:</strong> <span id="protocolStatus">üìç Detectando...</span>
            </div>
        </div>

        <div class="controls">
            <div>
                <input type="text" id="userIdInput" placeholder="Tu User ID" value="user1">
                <input type="text" id="tokenInput" placeholder="JWT Token" value="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJ1c2VyMSIsInVzZXJuYW1lIjoidGVzdCIsImlhdCI6MTczMjE2MzUyMH0.X8f7V5wMGLCzOsIWcBrWqJZBvSJYDVa3U_C_TuZg9Bc">
            </div>
            <button onclick="connect()">üîó Conectar</button>
            <button onclick="disconnect()">üîå Desconectar</button>
        </div>

        <div class="controls">
            <input type="text" id="targetUserInput" placeholder="User ID destinatario" value="user2">
            <button onclick="startCall()" id="callBtn" disabled>üìû Iniciar Llamada</button>
            <button onclick="endCall()" id="endBtn" disabled>üì≤ Colgar</button>
            <button onclick="toggleMute()" id="muteBtn" disabled>üîá Mute</button>
        </div>

        <div class="logs" id="logs">
            <div class="log-entry log-info">üìã Logs de seguridad aparecer√°n aqu√≠...</div>
        </div>
    </div>

    <script>
        let ws = null;
        let peerConnection = null;
        let localStream = null;
        let currentCallId = null;
        let isMuted = false;

        const userId = 'user1';
        const logs = document.getElementById('logs');

        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
            logs.appendChild(entry);
            logs.scrollTop = logs.scrollHeight;
            console.log(message);
        }

        async function connect() {
            const token = document.getElementById('tokenInput').value;
            const userId = document.getElementById('userIdInput').value;
            
            if (!token) {
                log('‚ùå Token requerido', 'error');
                return;
            }

            try {
                // üîí Detectar protocolo autom√°ticamente para WSS
                const isSecure = location.protocol === 'https:';
                const wsProtocol = isSecure ? 'wss:' : 'ws:';
                const wsUrl = `${wsProtocol}//${location.host}?token=${encodeURIComponent(token)}`;
                
                log(`üîó Conectando via ${wsProtocol.toUpperCase()}...`, 'security');
                ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    log(`‚úÖ Conectado al servidor via ${wsProtocol.toUpperCase()}`, 'security');
                    
                    // üîí Actualizar estado de seguridad de se√±alizaci√≥n
                    const signalingStatus = isSecure 
                        ? 'üîí HTTPS + WSS (Cifrado)' 
                        : '‚ö†Ô∏è HTTP + WS (Sin cifrar)';
                    
                    document.getElementById('signalingStatus').innerHTML = signalingStatus;
                    document.getElementById('callBtn').disabled = false;
                    
                    // Log completo de seguridad
                    if (isSecure) {
                        log('üõ°Ô∏è Se√±alizaci√≥n: TLS + WebSocket Secure activo', 'security');
                    } else {
                        log('‚ö†Ô∏è Se√±alizaci√≥n sin cifrar - Recomendado usar HTTPS', 'warning');
                    }
                };

                ws.onmessage = async (event) => {
                    const data = JSON.parse(event.data);
                    await handleSignalingMessage(data);
                };

                ws.onclose = () => {
                    log('üîå Desconectado del servidor', 'warning');
                    document.getElementById('signalingStatus').innerHTML = 'üîå Desconectado';
                    document.getElementById('callBtn').disabled = true;
                };

                ws.onerror = (error) => {
                    log('‚ùå Error de WebSocket: ' + error, 'error');
                };

            } catch (error) {
                log('‚ùå Error conectando: ' + error.message, 'error');
            }
        }

        function disconnect() {
            if (ws) {
                ws.close();
                ws = null;
            }
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            document.getElementById('webrtcStatus').innerHTML = '‚è≥ Sin conexi√≥n';
            document.getElementById('srtpStatus').innerHTML = '‚è≥ Pendiente';
        }

        async function startCall() {
            const targetUser = document.getElementById('targetUserInput').value;
            if (!targetUser || !ws) {
                log('‚ùå Especifica usuario destinatario y conecta primero', 'error');
                return;
            }

            try {
                // Obtener configuraci√≥n ICE del servidor
                const response = await fetch('/api/ice');
                const iceConfig = await response.json();
                log('üì° ICE servers obtenidos', 'info');

                // Crear PeerConnection con configuraci√≥n segura
                peerConnection = new RTCPeerConnection({
                    iceServers: iceConfig.iceServers,
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require'
                });

                // Eventos de seguridad
                peerConnection.onconnectionstatechange = () => {
                    log(`üîó Estado de conexi√≥n: ${peerConnection.connectionState}`, 'info');
                    document.getElementById('webrtcStatus').innerHTML = `üîó ${peerConnection.connectionState}`;
                    
                    if (peerConnection.connectionState === 'connected') {
                        checkEncryption();
                    }
                };

                peerConnection.onicecandidate = (event) => {
                    if (event.candidate && ws) {
                        ws.send(JSON.stringify({
                            type: 'ice',
                            candidate: event.candidate,
                            to: targetUser
                        }));
                    }
                };

                // Obtener stream de audio
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });

                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // Crear offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                // Validar SDP
                if (validateSdpFingerprint(offer.sdp)) {
                    log('‚úÖ SDP con DTLS fingerprint v√°lido', 'security');
                } else {
                    log('‚ö†Ô∏è SDP sin fingerprint DTLS', 'warning');
                }

                // Enviar invitaci√≥n
                ws.send(JSON.stringify({
                    type: 'call-invite',
                    to: targetUser,
                    callType: 'audio'
                }));

                log(`üìû Llamada iniciada a ${targetUser}`, 'info');
                document.getElementById('callBtn').disabled = true;
                document.getElementById('endBtn').disabled = false;

            } catch (error) {
                log('‚ùå Error iniciando llamada: ' + error.message, 'error');
            }
        }

        function endCall() {
            const targetUser = document.getElementById('targetUserInput').value;
            
            if (currentCallId && ws) {
                ws.send(JSON.stringify({
                    type: 'call-end',
                    callId: currentCallId,
                    to: targetUser
                }));
            }

            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            currentCallId = null;
            log('üì≤ Llamada finalizada', 'info');
            document.getElementById('callBtn').disabled = false;
            document.getElementById('endBtn').disabled = true;
            document.getElementById('muteBtn').disabled = true;
            document.getElementById('webrtcStatus').innerHTML = '‚è≥ Sin conexi√≥n';
            document.getElementById('srtpStatus').innerHTML = '‚è≥ Pendiente';
        }

        function toggleMute() {
            if (!localStream) return;

            isMuted = !isMuted;
            localStream.getAudioTracks().forEach(track => {
                track.enabled = !isMuted;
            });

            document.getElementById('muteBtn').innerHTML = isMuted ? 'üîä Unmute' : 'üîá Mute';
            log(`üîä Audio ${isMuted ? 'muteado' : 'activado'}`, 'info');
        }

        async function handleSignalingMessage(data) {
            log(`üì® Mensaje: ${data.type}`, 'info');

            switch (data.type) {
                case 'connected':
                    log(`üîí ${data.encryption}`, 'security');
                    break;

                case 'incoming-call':
                    currentCallId = data.callId;
                    if (confirm(`üìû Llamada entrante de ${data.from}. ¬øAceptar?`)) {
                        await acceptCall(data);
                    } else {
                        rejectCall(data);
                    }
                    break;

                case 'call-accepted':
                    currentCallId = data.callId;
                    log(`‚úÖ ${data.encryption}`, 'security');
                    await sendOffer();
                    break;

                case 'offer':
                    await handleOffer(data);
                    break;

                case 'answer':
                    await handleAnswer(data);
                    break;

                case 'ice':
                    await handleIceCandidate(data);
                    break;

                case 'call-ended':
                    endCall();
                    break;
            }
        }

        async function sendOffer() {
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            const targetUser = document.getElementById('targetUserInput').value;
            ws.send(JSON.stringify({
                type: 'offer',
                sdp: offer.sdp,
                to: targetUser
            }));

            log('üì§ Offer enviado con DTLS', 'security');
        }

        async function checkEncryption() {
            if (!peerConnection) return;

            peerConnection.getStats().then(stats => {
                stats.forEach(report => {
                    if (report.type === 'transport') {
                        const dtlsState = report.dtlsState;
                        const srtpCipher = report.srtpCipher;
                        
                        if (dtlsState === 'connected') {
                            log(`üîí DTLS conectado: ${srtpCipher || 'Cipher desconocido'}`, 'security');
                            document.getElementById('srtpStatus').innerHTML = 'üîí SRTP Activo';
                        }
                    }
                });
            });
        }

        function validateSdpFingerprint(sdp) {
            return sdp && sdp.includes('a=fingerprint:') && sdp.includes('sha-256');
        }

        // Inicializar - Detectar protocolo autom√°ticamente
        function initializeSecurityStatus() {
            const isSecure = location.protocol === 'https:';
            const protocolInfo = isSecure 
                ? 'üîí HTTPS (Seguro)' 
                : '‚ö†Ô∏è HTTP (No seguro)';
            
            document.getElementById('protocolStatus').innerHTML = protocolInfo;
            
            log('üöÄ Cliente WebRTC cargado', 'security');
            log(`üìç Protocolo detectado: ${location.protocol}`, 'info');
            
            if (isSecure) {
                log('‚úÖ Listo para HTTPS + WSS + SRTP (seguridad completa)', 'security');
            } else {
                log('‚ö†Ô∏è HTTP detectado - Para seguridad completa usar HTTPS', 'warning');
                log('üí° Recomendaci√≥n: generate-ssl.bat y USE_SSL=true', 'info');
            }
        }

        // Inicializar al cargar la p√°gina
        initializeSecurityStatus();
    </script>
</body>
</html>